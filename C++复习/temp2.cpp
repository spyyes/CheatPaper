// 面向对象的程序设计 四个特点：
// 抽象 封装 继承 多态
对象可以赋值，但是不能比较（除非已重载）
class Rectangle{
    public:
    int w,h;
    int Area();
}
int Rectangle::Area(){
    return w * h;
}
private：只有在成员函数内部访问
顺序和次数没有限制
如果某个成员前面没有关键字，则缺省地默认为私有成员

成员函数内部可以访问；
当前对象和同类其他对象的全部属性和函数
在成员函数以外的地方：只能访问该类的共有成员，否则会编译出错！

class声明的结束必须有分号!!!

设置私有成员：目的是“隐藏”
使用缺省参数应该避免二义性，否则会编译错误

构造函数的意义：
（1）专门的位置初始化，而且不用担心没有写
（2）有些没有初始化就使用的对象，会导致程序出错
构造函数最好是public的

构造函数在数组使用

Test array[3] = {1, Test(1,2) };//3次
Test * array[3] = {new Test(1), new Test(1,2)}; //2次
new Test[3];//3次

赋值构造函数，只有一个参数，同类对象的引用
X::X(const X&)
X::X(X&)
复制构造函数起作用的三种情况：
（1）用一个对象初始化另一个对象
Complex c2 = c1; //注意这是初始化，不是赋值
（2）某函数的参数之一是A的对象，在函数调用时，类A的复制构造函数被调用
（3）如果返回值是类A的对象，那么函数返回时，A的复制构造函数被调用

注意：对象间赋值语句不会调用复制构造函数

因此，如果一个函数需要调用一个对象为参数，最好选择调用引用，如果害怕修改了这个值，可以加const关键字。

类型转换构造函数
只有一个参数，而且不是复制构造函数的构造函数，就可以看做是类型转换构造函数

delete运算导致析构函数调用
对于数组，需要写delete[]，否则只会调用1次析构函数

d4 = 6;//调用两次构造函数
static在global之前析构

new出来的对象要手动delete!!!

DEV编译器出于优化的目的，可能并未生成返回值临时对象

静态成员函数不能使用this指针

静态成员变量：所有对象共享
sizeOf不会计算静态成员变量
不需要对象就能访问 Rectangle::PrintTotal();

A* p = Null;
p -> Hello(); //正常运行
被翻译为Hello(A* this){}
于是运行为Hello(p)

静态成员变量本质也是全局变量，哪怕一个对象都不存在，静态成员变量也存在
静态成员函数本质也是全局函数
将与某些类相关的变量和函数写到类里面，看上去像是一个整体，便于维护和理解

!!!必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则编译能通过，链接不能通过
static和是否private不冲突

封闭类：有成员对象的类
封闭类的调用顺序：成员对象先调用，而且顺序和声明有关，和初始化顺序无关

友元函数：可以访问私有成员


常量对象只能使用构造函数 析构函数和有const说明的函数
如果不是const函数，会编译出错
在【定义】和【声明】常量成员函数时必须使用const关键字；
void PrintValue() const;
void Sample::PrintValue() const{

}//如果不加const会编译出错

两个函数，名字和参数表都一样，但是一个是const一个不是，算重载。

mutable成员变量：可以在const成员函数中修改的成员变量。


