###1  函数指针

1. 函数指针的写法：

   ```c++
   int add_int(int a, int b){
       return a + b;
   }
   int main(int a, int b){
       //函数指针的写法 必须有括号；前面是返回值；后面是参数类型；*后面是指针的名字
       int (*add)(int, int);
       //函数指针的赋值
       add = add_int;
       c = add(a, b);
       return c;
   }
   ```

2. 函数指针的用途举例 -- qsort。要让qsort能够对任意类型数组排序，调用 qsort 时必须提供哪些信息？

   - 数组起始地址
   - 数组元素大小，
   - 数组元素个数，
   - 用于比较数组元素的比较函数

3. qsort的实现方式：

      ​	qsort返回-1，代表第一个应该排在第二个之前，不需要移动位置；返回0，代表都可以；返回1，代表第一个应该排在第二个后面，需要移动位置。

4. qsort的应用代码：

      ```c++
      //定义用于比较的函数，注意返回值是int，参数必须是两个const void *
      int myCompare(const void * a, const void * b){
          //void * 由于不知道参数的类型大小，因此取值难以确定，所以必须要强制类型转换。
          unsigned int * a = (unsigned int *)a; 
          unsigned int * b = (unsigned int *)b;
          //注意传进来的是指针，所以要加*取值。
          return *p1 - *p2;
      }
      int main(int a, int b){
          unsigned int nums[5] = {0,1,3,4,2};
          //qsort调用myCompare。这里myCompare本来应该是函数指针，用函数名代替也可以。
          qsort(nums, 5, sizeof(unsigned int), myCompare);
          return 0;
      }
      ```


### 2 内联函数&函数重载&缺省参数

1. 编译器将内联函数写到函数里面。
2. 函数重载：名字相同，但是参数个数或类型不同。使得函数命名变得简单。有时候不确定的时候，编译器会报错。
3. **如果函数名和参数都一样，但是返回值类型不一样，这不叫函数重载，这叫重复定义。**
4. 缺省值：只有最右边的参数可以由缺省值。意义在于可以提高程序的可扩充性，如果后来程序要添加新的参数，原来的调用语句可以不用改。
5. 如果第二和第三个参数都有缺省值，也不可以只写第三个参数，越过第二个参数不写。

### 3 位运算

&：①某些位清零，其他位不变。② 获取变量中的某一位。

​	例：判断第7位是不是1：`n&=0x80 == 0x80`

|：①某些位置1，其他位不变。

^：①**某些位取反，其他位不变。和1异或取反，和0亦或是本身。**

​	例：低8位取反：`n^= 0xff`

​	② **a ^ b = c，则 c ^ a = b , c ^ b = a。（穷举法）**

​	可以做简单的加密和解密。

​	③**不通过临时变量，进行交换变量的值。（穷举法）**

​	a = a ^ b; b = b ^ a; a = a ^ b;

~：

<< ：高位丢弃，低位补0。左移n位，就是乘以2的n次方，比乘法快很多。

\>>：如果原符号数为1，右移时高位补1，如果原符号数为0，右移时高位补0。（C/C++编译器规定）

​	 **相当于除以2的n次方，有可能除不尽，小里取整（-1.xxx = -2) **

思考题：

写一个表达式，使得该表达式和a的第n位相同：

​	( a >> n )& 1 

或者： (a & (1<<n) )>> n

需要注意n < 31，如果n = 31，第二种方法不对。因为a的最高位是1，右移的时候可能导致符号方式右移。

### 4. 引用

```
int n = 4;
int & n = 6;
```

定义引用时一定需要初始化引用某个变量。

从一而终。

不能引用常量和**表达式**。

```C++
int a = 4, b = 4;
int & aa = a;
int & b = a * 5; //出错，不能引用表达式
```

**在C和C++语言中交换两个变量的值。**

```C
//通过地址对变量的值进行交换
void swap(int *a, int *b){
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}
int n1, n2;
swap(&n1, &n2);
```

```c++
//C++有了引用的概念
void swap(int & a, int & b){
    int tmp;
    tmp = a;
    a = b;
    b = tmp;
}
int n1, n2;
swap(n1, n2);
```

引用还可以作为函数的返回值：这样就可以将函数调用写在左边进行赋值。更多功能之后会再讲述。

```C++
int & setValue(){
	return n;
}
int main(){
    SetValue() = 40;
}
```

常引用：不能通过常引用修改引用的内容。

```C++
const int & r = n;
n = 200; //没问题
r = 200; //出错
```

**常引用和非常引用之间可以转换**

```C++
//const T& 和T&是不同的类型。
T& 类型的引用 或 T 类型的变量 可以初始化 const T& 类型的引用。
const T 类型的常变量 和 const T& 类型的常引用不能用来初始化T&类型的引用，除非进行强制类型转换。
```

### 5. 常量

**常量指针：**

```C++
const char * NAME = "Peking University"
const int * p = & n; 
```

不可以通过常量指针修改其指向的内容

不能把常量之后赋值给非常量指针，反过来可以。因为常量指针指向的内容通常不希望被修改。

当然可以通过强制类型转换实现。

```C++
const int *p1, int * p2; //p1是常量指针，p2是普通指针
p1 = p2; //ok
p2 = p1; //error
p2 = (int *) p1; //强制类型转换
```

函数传参时，把函数参数写成常量指针，可以避免函数内部不小心改变参数指针所指向的地方的内容。

```C++
void prinff(const char * p){
    strcpy(p, "this"); //尝试修改p的内容，编译出错。出错的原理是"this"的类型是char*, 而p的类型是const char *，类型不匹配。
}
```



## 第二章 类和对象初探

### 1 面向对象程序设计方法

结构化程序设计的四大困难：理解难、修改难、查错难、重用难。

因此产生了面向对象程序设计方法。

设计思路：面向对象的程序：就是构建不同的类。设计类的过程。

将一类事物抽象成 共同属性和行为，并封装成类。抽象和封装是主要的设计过程。

类的定义：

```C++
class 类名
{
    访问范围说明符
    	成员变量
    	...
};
```

### 2 类

1. 成员变量和成员函数统称为类的成员。

2. **class 声明类后必须有分号；**

3. 对象之间可以使用 = 赋值，但是不能使用 == > 等进行比较，在进行运算符重载之后可以。

4. 访问类的成员变量和成员函数：

   对象名.成员名

   指针- > 成员名

   引用.成员名

```c++
CRectangle r1, r2;
CRectangle * p1 = & r1;
p1 -> w = 3;

CRectangle & rr1 = r1;
rr1.w = 5;
```

5. 类的成员函数体和类的定义分开写

```c++
int CRectangle::Area(){
    return w * h;
}
```

6. 类成员的可访问范围

   三种关键字出现的次数和先后顺序都没有限制。

   缺省为private，只能在成员函数中访问。

   类的成员函数内部可以访问**当前对象和同类其他对象的全部属性和函数**

   成员函数外部只能访问共有成员。

   这样有两个好处：一是避免程序出错，二来易于程序修改。

7. 内联成员函数

   inline + 成员函数， 可以不在类里定义，只在类里声明。

   函数体放在class里面，本身就是内联成员函数。

8. 成员函数的重载和参数缺省

   使用缺省参数时需要避免有函数重载时的二义性

   ```
   int value (int x = 0) {}
   int value() {}
   ```

9. 构造函数

   名字和类名相同，可以有参数，但是不能有返回值。

   如果声明了构造函数，编译器就不会生成默认构造函数。

   ```C++
   Complex *p = new Complex(1);
   Complex c1(2);
   Complex C1(1), C2(2), C3(3);
   ```

   一个类可以由多个构造函数，只要参数类型或数目不一样就可以。（重载）

10. **构造函数在对象数组中使用**(**注意写法**)

   ```C++
   class Complex{
    	int real;
       int image;
       Complex(int r);
       Complex(int a, int b);
   };
   Complex::Complex(int r){
       real = r;
       image = 0;
   }
   Complex::Complex(){
       real = 0;
       image = 0;
   }
   int main(){
       Complex array1[2]; //两次无参构造函数
       Complex array2[2] = {1, 2}; //两次有参构造函数
       Complex array3[2] = {1}; //一次有参构造函数，一次无参构造函数
       Complex * array4 = new Complex[2]; //两次无参构造函数
       delete[] array4;//new出来的要delete
   }
   ```

11. **构造函数在数组中的使用2**

```C++
class Test{
    public:
    Test(int n){}   //(1)
    Test(int a, int b){}	//(2)
    Test(){}	//(3)
};
Test array1[3] = {1, Test(1,3)};  //(1)(2)(3)
Test array2[3] = {Test(2,3), Test(1,2), 1};	//(2)(2)(1)
Test * pArray[3] = {new Test(4), new Test(1,2)}; //(1)(2)
//注意：第三个是指针数组，实际上创建了两个对象，第3个指针没有指定对象。
```

## 第三章  类的进阶

### 1. 复制构造函数

只有一个参数，对同类对象的引用。形如：

```c++
X::X(X&)
X::X(const X &)
```

如果没有定义复制构造函数，就会生成默认的复制构造函数。如果定义了自己的复制构造函数，则默认的复制构造函数不存在。

```c++
class Complex{
    private:
    double real, image;
};
Complex c1;		//调用缺省的无参构造函数
Complex c1(c2); //调用缺省的复制构造函数，将c2初始化成和c1一样
```

定义复制构造函数。

