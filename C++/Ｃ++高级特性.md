

### C++条件编译

```
     指令             用途
    #           空指令，无任何效果
    #include    包含一个源代码文件
    #define     定义宏
    #undef      取消已定义的宏
    #if         如果给定条件为真，则编译下面代码
    #ifdef      如果宏已经定义，则编译下面代码
    #ifndef     如果宏没有定义，则编译下面代码
    #elif       如果前面的#if给定条件不为真，当前条件为真，则编译下面代码，其实就是else if的简写
    #endif      结束一个#if……#else条件编译块
    #error      停止编译并显示错误信息
```

#define 可以定义一个函数，如

```c++
#define _MAX(a,b)        ((a) > (b) ? (a) : (b))
```

### C++ enum枚举量

**定义和声明**

```c++
enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};
```

-  第一：声明 enumType 为新的数据类型，称为枚举(enumeration); 
-  第二：声明 Monday、Tuesday 等为符号常量，通常称之为枚举量，其值默认分别为 0-6。（后面会介绍怎样显式的初始化枚举量的值） 

可以用这种新的枚举类型定义这种类型的变量，也可以在定义枚举类型时定义枚举常量。

```c++
enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
```

**几个注意点：**

- 在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，如：Weekday = Monday; 也可以通过强制转换。如 Weekday = enumType(2)。如果超出范围，那么不会出错，但是得到想要的结果，结果不确定。
- 可以将枚举量赋值给非枚举变量，也可以进行计算。
- 枚举变量不能进行算术运算，因为只定义了赋值运算符，没有定义算数运算符。

**自定义枚举量的值**

- 可以全部定义，也可以部分定义。未被初始化的枚举值将默认比前面的枚举值+1
- 枚举量的值可以相同
- 在强制类型转换将其他类型的值赋给枚举变量时，枚举上限是 最大枚举量的最小的2的幂-1。枚举下限是0 | 最小枚举量的最大的2的幂 +１．

**其他注意事项：**

枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合：

-  枚举中每个成员(标识符)结束符是 `,` ，不是` ;` ，最后一个成员可省略 `,` ； 
-  初始化时可以赋负数，以后的标识符仍依次加1； 
-  在C语言中，枚举类型名包括关键字enum，在C++中允许不写enum，一般也不写enum，但保留了C的用法； 
-  枚举值可以用来作判断比较； 
-  定义的枚举的元素后，在程序运行过程就不能改变。 

### extern关键字

**作用**

1. 放在函数或者变量前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
2. 与“C”连用，作为连接指定。

extern只是声明，没有定义。

**extern函数或变量**

声明函数或全局变量的作用范围，其声明的函数和变量可以在本模块或其他模块使用。如果B模块要引用A的全局变量或函数时，只要包含A模块的头文件即可。

**extern和static的区别**

- extern和static不能同时修饰一个变量
- static修饰的全局变量声明与定义同时进行
- static修饰全局变量的作用域只能是本身的编译单元。虽然它们有相同的内容，但是存储的物理地址并不一样，多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份。
- 一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！

**extern和const的区别**

const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中

**const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的，** 
前面那个const 修饰的是char \*而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你像让char\*g_str遵守const的全局常量的规则，最好这么定义const char* const g_str="123456".

**extern "c"**

历史遗留问题，最早的标准C编译器编译引用出来的变量和函数就是在名字前面加个下滑杠，比如void foo(int a,int b);编译器引用的函数名是_foo，后来的C编译器都是遵循这个标准。

可是后来C++出现了，他的重载特性使得不同的编译器对它进行了不同的处理，比如void foo(int a,int b);就可能被编译器引用出来后变为_foo_int_int之类的，把函参也放进函数名中，从而实现了重载。为了保证不同厂家生产的模块之间的兼容性，并且可以调用原先开发好的C模块，就引出了一个extern "C"的方法，通过这种定义来告诉编译器：请按照C的方法来对我这个函数进行编译，保持我的名称。这样不同厂家的C和C++中的变量，函数，类就得到了一致化的处理，兼容性也就解决了。

参考：https://blog.csdn.net/jackystudio/article/details/11670303

### static关键字

**作用1：隐藏**

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

**作用2：保持变量内容的持久**

在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

**作用3：默认初始化为0**

**static全局变量与普通的全局变量有什么区别 ?**

这两者在存储方式上并无不同，都是静态存储方式。

区别在于：非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。  而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 

而且只能初始化一次。

**static局部变量和普通的局部变量有什么区别？**

改变了它的存储方式即改变了它的**生存期**。

而且只能初始化一次。

static函数在内存中只有一份，普通函数在每个被调用中维护一份拷贝。

### C++强制类型转换

**标准C++中有四个类型转换符：**static_cast、dynamic_cast、reinterpret_cast、和const_cast

**static_cast**

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。

应用场景：

- void指针-> 其他类型的指针
- 改变通常的标准转换
- 避免出现可能多种转换的歧义

不能转换掉expression的const\volitale\__unaligned属性。

**dynamic_cast**

把expression转换成type-id类型的对象。

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。

此外还有reinpreter_cast和const_cast。

 ### (void)

C/C++语句 "(void) 变量名;" 的作用是，避免未使用变量的编译警告。